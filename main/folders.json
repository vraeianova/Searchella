{"apicall.go":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc main() {\n\tquery := `{\n        \"search_type\": \"match\",\n        \"query\":\n        {\n            \"term\": \"Wed, 13 Dec 2000 13:09:00 -0800 (PST)\"\n            \n        },\n        \"from\": 0,\n        \"max_results\": 20,\n        \"_source\": []\n    }`\n\treq, err := http.NewRequest(\"POST\", \"http://localhost:4080/api/messages/_search\", strings.NewReader(query))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treq.SetBasicAuth(\"admin\", \"Complexpass#123\")\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36\")\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\tlog.Println(resp.StatusCode)\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(body))\n}\n","filereader.go":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\n// Record es la estructura que representa un registro del archivo\ntype Record struct {\n\tMessageID               string `json:\"Message-ID\"`\n\tDate                    string `json:\"Date\"`\n\tFrom                    string `json:\"From\"`\n\tTo                      string `json:\"To\"`\n\tSubject                 string `json:\"Subject\"`\n\tMimeVersion             string `json:\"Mime-Version\"`\n\tContentType             string `json:\"Content-Type\"`\n\tContentTransferEncoding string `json:\"Content-Transfer-Encoding\"`\n\tXFrom                   string `json:\"X-From\"`\n\tXTo                     string `json:\"X-To\"`\n\tXcc                     string `json:\"X-cc\"`\n\tXbcc                    string `json:\"X-bcc\"`\n\tXFolder                 string `json:\"X-Folder\"`\n\tXOrigin                 string `json:\"X-Origin\"`\n\tXFileName               string `json:\"X-FileName\"`\n\tMessage                 string `json:\"Message\"`\n}\n\ntype Output struct {\n\tIndex   string   `json:\"index\"`\n\tRecords []Record `json:\"records\"`\n}\n\nfunc main() {\n\t// Abre el archivo\n\tfile, err := os.Open(\"2.\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Crea un slice de Record para almacenar los registros\n\tvar records []Record\n\n\tvar currentRecord Record\n\n\trecord := Record{}\n\n\t// Crea un escáner para leer el archivo línea a línea\n\tscanner := bufio.NewScanner(file)\n\n\t// Lee cada línea del archivo\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tfmt.Println(\"Verificando la línea\", line)\n\t\t// Divide la línea en clave y valor\n\t\tparts := strings.Split(line, \": \")\n\t\tif len(parts) != 2 {\n\t\t\tfmt.Println(\"Verificar que entro aqui en esta linea\", line)\n\t\t\t// La línea no tiene el formato esperado (clave: valor)\n\t\t\t// Añade el valor de la línea al campo Message\n\t\t\tcurrentRecord.Message += line + \"\\n\"\n\t\t\tcontinue\n\t\t}\n\t\tkey := parts[0]\n\t\tvalue := parts[1]\n\n\t\t// Crea una instancia de Record y asigna los valores de clave y valor a los campos correspondientes\n\t\t// record := Record{}\n\t\tswitch key {\n\t\tcase \"Message-ID\":\n\t\t\trecord.MessageID = value\n\t\tcase \"Date\":\n\t\t\trecord.Date = value\n\t\tcase \"From\":\n\t\t\trecord.From = value\n\t\tcase \"To\":\n\t\t\trecord.To = value\n\t\tcase \"Subject\":\n\t\t\trecord.Subject = value\n\t\tcase \"Mime-Version\":\n\t\t\trecord.MimeVersion = value\n\t\tcase \"Content-Type\":\n\t\t\trecord.ContentType = value\n\t\tcase \"Content-Transfer-Encoding\":\n\t\t\trecord.ContentTransferEncoding = value\n\t\tcase \"X-From\":\n\t\t\trecord.XFrom = value\n\t\tcase \"X-To\":\n\t\t\trecord.XTo = value\n\t\tcase \"X-cc\":\n\t\t\trecord.Xcc = value\n\t\tcase \"X-bcc\":\n\t\t\trecord.Xbcc = value\n\t\tcase \"X-Folder\":\n\t\t\trecord.XFolder = value\n\t\tcase \"X-Origin\":\n\t\t\trecord.XOrigin = value\n\t\tcase \"X-FileName\":\n\t\t\trecord.XFileName = value\n\t\t}\n\n\t\t// Agrega la instancia de Record al slice\n\n\t}\n\trecord.Message = currentRecord.Message\n\trecords = append(records, record)\n\n\t// fmt.Println(\"Verificando la salida de records\", records)\n\t// fmt.Println(\"Verificando la salida de currentRecord\", currentRecord.Message)\n\tfmt.Println(\"Verificando la salida de records con el mensaje\", records)\n\n\t// Verifica si hubo algún error al leer el archivo\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\toutput := Output{\n\t\tIndex:   \"messages\",\n\t\tRecords: records,\n\t}\n\n\toutputJSON, err := json.Marshal(output)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Exporta la cadena de caracteres de formato JSON a un archivo\n\terr = ioutil.WriteFile(\"output.json\", outputJSON, 0644)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n}\n","main.go":"package main\n\nfunc main() {\n\t// r := chi.NewRouter()\n\n\t// // Usa middleware para manejar el registro y las solicitudes con formato JSON\n\t// r.Use(middleware.Logger)\n\t// r.Use(middleware.Recoverer)\n\n\t// r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t// \tw.Write([]byte(\"Hello World!\"))\n\t// })\n\t// http.ListenAndServe(\":9001\", r)\n\tmux := Routes()\n\tserver := NewServer(mux)\n\tserver.Run()\n}\n","python_testing.py":"import base64, json\nimport requests\n\nuser = \"admin\"\npassword = \"Complexpass#123\"\nbas64encoded_creds = base64.b64encode(bytes(user + \":\" + password, \"utf-8\")).decode(\"utf-8\")\n\n\ndata = {\n    \"Athlete\": \"DEMTSCHENKO, Albert\",\n    \"City\": \"Turin\",\n    \"Country\": \"RUS\",\n    \"Discipline\": \"Luge\",\n    \"Event\": \"Singles\",\n    \"Gender\": \"Men\",\n    \"Medal\": \"Silver\",\n    \"Season\": \"winter\",\n    \"Sport\": \"Luge\",\n    \"Year\": 2006\n  }\n\nheaders = {\"Content-type\": \"application/json\", \"Authorization\": \"Basic \" + bas64encoded_creds}\nindex = \"testing\"\nzinc_host = \"http://localhost:4080\"\nzinc_url = zinc_host + \"/api/\" + index + \"/document\"\n\nres = requests.put(zinc_url, headers=headers, data=json.dumps(data))\n\n\n","python_testing2.py":"import base64\nimport json\nimport requests\n\nuser = \"admin\"\npassword = \"Complexpass#123\"\nbas64encoded_creds = base64.b64encode(bytes(user + \":\" + password, \"utf-8\")).decode(\"utf-8\")\n\nparams = {\n    \"search_type\": \"match\",\n    \"query\":\n    {\n        \"term\": \"a\",\n        \n    },\n    \"from\": 0, # use together with max_results for paginated results.\n    \"max_results\": 20,\n    \"_source\": [] # Leave this as empty array to return all fields.\n}\n\n# params = {\n#     \"search_type\": \"querystring\",\n#     \"query\":\n#     {\n#         \"term\": \"+City:Turin +Silver\",\n#         \"start_time\": \"2021-06-02T14:28:31.894Z\",\n#         \"end_time\": \"2021-12-02T15:28:31.894Z\"\n#     },\n#     \"_source\": [\"_all\"]\n# }\n\nheaders = {\"Content-type\": \"application/json\",  \"Authorization\": \"Basic \" + bas64encoded_creds}\nindex = \"testing\"\nzinc_host = \"http://localhost:4080\"\nzinc_url = zinc_host + \"/api/\" + index + \"/_search\"\n\nres = requests.post(zinc_url, headers=headers, data=json.dumps(params))\n\nprint(res.text)\n","routes.go":"package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc Routes() *chi.Mux {\n\n\tmux := chi.NewMux()\n\n\t//Global Middleware\n\tmux.Use(\n\t\tmiddleware.Logger,\n\t\tmiddleware.Recoverer,\n\t)\n\n\t//mux.Get(\"/search\", nil)\n\tmux.Get(\"/search\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// w.Write([]byte(\"Welcome to my website!\"))\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Header().Set(\"done-by\", \"Cris\")\n\n\t\tres := map[string]interface{}{\"message\": \"Hello search\"}\n\n\t\t_ = json.NewEncoder(w).Encode(res)\n\t})\n\treturn mux\n}\n","server.go":"package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi\"\n)\n\ntype SearchellaServer struct {\n\tserver *http.Server\n}\n\nfunc NewServer(mux *chi.Mux) *SearchellaServer {\n\ts := \u0026http.Server{\n\t\tAddr:           \":9000\",\n\t\tHandler:        mux,\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   10 * time.Second,\n\t\tMaxHeaderBytes: 1 \u003c\u003c 20,\n\t}\n\treturn \u0026SearchellaServer{s}\n}\n\nfunc (s *SearchellaServer) Run() {\n\ts.server.ListenAndServe()\n}\n","test.go":"package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// Función recursiva para obtener todas las carpetas de un directorio\nfunc getFolders(path string) map[string]interface{} {\n\t// Crear un mapa para almacenar las carpetas del directorio\n\tfolders := make(map[string]interface{})\n\n\t// Iterar sobre los elementos del directorio\n\tentries, err := ioutil.ReadDir(path)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn folders\n\t}\n\t// fmt.Println(\"Verificar las entries\", entries)\n\tfor _, entry := range entries {\n\t\t// Obtener la ruta completa del elemento\n\t\tfullPath := filepath.Join(path, entry.Name())\n\n\t\t// Verificar si el elemento es una carpeta\n\t\tif entry.IsDir() {\n\t\t\tfmt.Println(\"Es directorio\", entry.Name())\n\t\t\t// Agregar la carpeta al mapa y obtener las carpetas\n\t\t\t// contenidas en la carpeta\n\t\t\tfolders[entry.Name()] = getFolders(fullPath)\n\t\t} else {\n\n\t\t\tb, err := ioutil.ReadFile(fullPath)\n\t\t\tif err != nil {\n\t\t\t\t// Si hay un error al leer el archivo, imprimimos el error y terminamos el programa\n\t\t\t\tfmt.Println(err)\n\n\t\t\t}\n\t\t\tfmt.Println(\"Encontré un archivo\", entry.Name())\n\n\t\t\t// Convertimos la matriz de bytes en una cadena y la imprimimos en la consola\n\t\t\tstr := string(b)\n\t\t\t// fmt.Println(str)\n\t\t\tfolders[entry.Name()] = str\n\n\t\t}\n\t}\n\n\t// Devolver el mapa de carpetas\n\treturn folders\n}\n\nfunc exportJSON(jsonData []byte) error {\n\t// Crear un archivo en el directorio actual\n\tfile, err := os.Create(\"folders.json\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\t// Escribir el JSON en el archivo\n\t_, err = file.Write(jsonData)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// Obtener el directorio actual\n\tcurrentDir, err := os.Getwd()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfolders := getFolders(currentDir)\n\n\tjsonData, err := json.Marshal(folders)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Escribir el JSON en un archivo en el directorio actual\n\tfile, err := os.Create(\"folders.json\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t_, err = file.Write(jsonData)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n}\n","testing_data.json":"{\n    \"index\": \"names\",\n    \"records\": [\n        {\n            \"name\": \"Prabhat Sharma\",\n            \"age\": 18\n        },\n        {\n            \"name\": \"Daniel Sharma\",\n            \"age\": 36\n        }\n    ]\n}","testing_server.go":"package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc main() {\n\tr := chi.NewRouter()\n\tr.Use(middleware.Logger)\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello World!\"))\n\t})\n\thttp.ListenAndServe(\":3000\", r)\n}\n"}